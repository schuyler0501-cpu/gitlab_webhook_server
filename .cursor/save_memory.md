# 如何保存有效对话

## 快速保存指令

当与 AI 对话后，如果有一些重要的指令或偏好需要记住，可以：

### 方法 1: 直接告诉我保存

在对话中直接说：
```
请将以下内容保存到记忆文件中：
- 我偏好使用中文注释
- 所有错误处理都要包含上下文
- 新功能必须先写测试
```

### 方法 2: 使用记忆命令

在对话中使用特殊格式：
```
@memory 保存: 我偏好使用表驱动测试，所有测试函数都要使用这个模式
```

### 方法 3: 手动编辑

直接编辑 `.cursor/memory.md` 文件，添加你的偏好和指令。

## 应该保存什么？

### ✅ 应该保存
- 代码风格偏好（注释语言、命名风格等）
- 开发习惯（测试优先、代码审查关注点等）
- 项目特定要求（业务规则、技术决策等）
- 常用代码模式
- 禁止事项
- 重要的技术决策

### ❌ 不应该保存
- 临时性的问题
- 一次性的代码片段
- 已经解决的问题
- 过于具体的实现细节

## 记忆文件结构

记忆文件 (`.cursor/memory.md`) 包含以下部分：

1. **重要指令** - 核心偏好和要求
2. **项目特定要求** - 针对特定功能模块的要求
3. **常用模式** - 重复使用的代码模式
4. **禁止事项** - 明确不允许的做法
5. **待办事项** - 需要完成的任务
6. **更新记录** - 记录重要更新

## 示例

### 保存代码风格偏好
```
@memory 保存: 
代码风格偏好：
- 所有公开函数必须有中文注释
- 错误处理必须使用 fmt.Errorf 添加上下文
- 日志记录必须包含足够的上下文信息
```

### 保存项目要求
```
@memory 保存:
Webhook 处理要求：
- 所有 Webhook 事件必须记录完整日志
- Token 验证失败要返回 401 状态码
- 错误响应要包含错误类型和消息
```

### 保存常用模式
```
@memory 保存:
错误处理模式：
if err != nil {
    logger.Error("操作描述", zap.Error(err), zap.String("key", "value"))
    return fmt.Errorf("操作描述: %w", err)
}
```

## 更新记忆

### 添加新内容
在对话中说：
```
@memory 添加: 新功能开发时，先创建数据模型，再实现服务层
```

### 修改现有内容
在对话中说：
```
@memory 更新: 将"函数长度不超过 50 行"改为"函数长度不超过 80 行"
```

### 删除内容
在对话中说：
```
@memory 删除: 关于 XXX 的要求
```

## 验证记忆

在对话中问：
```
@memory 查看: 我的代码风格偏好是什么？
```

或者：
```
@memory 列出: 所有项目特定要求
```

## 最佳实践

1. **定期更新**: 当偏好或要求改变时，及时更新记忆文件
2. **保持简洁**: 只保存重要的、会重复使用的指令
3. **分类清晰**: 使用清晰的分类和标题
4. **添加日期**: 在更新记录中添加日期，便于追踪
5. **定期审查**: 定期审查记忆文件，删除过时的内容

---

**记住**: 记忆文件是为了让 AI 更好地理解你的偏好和要求，保持文件简洁和最新是最重要的。

